/**
 * Converts a hex string to a Uint8Array, supporting multiple hex lengths.
 *
 * @param hexKey - The hex string generated by `openssl rand -hex N`
 * @returns A Uint8Array with the raw bytes, compatible with crypto key import
 * @throws Error if hexKey length is not even (hex must be in pairs of two characters)
 */
function hexToUint8Array(hexKey: string): Uint8Array {
  if (hexKey.length % 2 !== 0) {
    throw new Error("Hex key length must be even.");
  }

  // Convert hex string to Uint8Array of raw bytes
  return new Uint8Array(
    hexKey.match(/.{1,2}/g)!.map((byte) => parseInt(byte, 16)),
  );
}

export async function getKey(keyUsages: KeyUsage[]) {
  // Check if stdin is a TTY
  if (Deno.stdin.isTerminal()) {
    console.error(
      "Error: No input received on stdin. Please pipe the secret into the program.",
    );
    Deno.exit(1);
  }

  // Read secret from stdin (buffer size accomodates max 256-bit entropy)
  const decoder = new TextDecoder();
  const buf = new Uint8Array(32);
  const nBytesRead = await Deno.stdin.read(buf);
  if (nBytesRead === null) {
    console.error("Failed to read secret from stdin");
    Deno.exit(1);
  }
  const secret = decoder.decode(buf.subarray(0, nBytesRead)).trim();

  // Convert hex string generated by `openssl rand -hex N` to Uint8Array
  const keyBytes = hexToUint8Array(secret);

  // Determine the key length in bytes (N hex characters)
  const VALID_KEY_LENGTHS = [16, 24, 32];

  if (!VALID_KEY_LENGTHS.includes(keyBytes.length)) {
    throw new Error(
      "Invalid key length. AES requires a key of 128, 192, or 256 bits. Try `openssl rand -hex ${N}` where N={16,24,32}.",
    );
  }

  // Prepare encryption key
  return await crypto.subtle.importKey(
    "raw",
    keyBytes.buffer as ArrayBuffer,
    "AES-CBC",
    false,
    keyUsages,
  );
}
